(() => {
  'use strict';

  // ---- Utilities -----------------------------------------------------------

  const enc = new TextEncoder();
  const dec = new TextDecoder();

  const b64e = (buf) => {
    const b = Array.from(new Uint8Array(buf)).map(x=>String.fromCharCode(x)).join('');
    return btoa(b);
  };
  const b64d = (str) => {
    const b = atob(str);
    const buf = new Uint8Array(b.length);
    for (let i=0; i<b.length; i++) buf[i] = b.charCodeAt(i);
    return buf.buffer;
  };
  const b64u = (buf) => b64e(buf).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  const b64uToBuf = (s) => {
    s = s.replace(/-/g,'+').replace(/_/g,'/');
    while (s.length % 4) s += '=';
    return b64d(s);
  };
  const hex = (buf) => Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');

  const sleep = (ms) => new Promise(r=>setTimeout(r, ms));

  // Safe JSON pack into a copy-paste string
  const pack = (obj) => {
    const json = JSON.stringify(obj);
    return b64u(enc.encode(json));
  };
  const unpack = (str) => {
    const json = dec.decode(b64uToBuf(str.trim()));
    return JSON.parse(json);
  };

  // HKDF helper
  async function hkdf(ikm, infoStr, length=32, saltBytes=null) {
    const salt = saltBytes ? saltBytes : new Uint8Array(32).buffer;
    const key = await crypto.subtle.importKey('raw', ikm, 'HKDF', false, ['deriveBits']);
    const info = enc.encode(infoStr);
    const bits = await crypto.subtle.deriveBits(
      { name: 'HKDF', hash: 'SHA-256', salt, info },
      key, length * 8
    );
    return bits; // ArrayBuffer
  }

  // SHA-256
  async function sha256(buf) {
    return await crypto.subtle.digest('SHA-256', buf);
  }

  // Derive a cute Short Authentication String (emoji + hex)
  function formatSAS(bytes) {
    // Take first 5 bytes: 2 emojis and 3 hex groups
    const arr = new Uint8Array(bytes);
    const emojis = [
      '🔒','🧩','✨','🌱','🔥','🌊','⚡','🌟','🍀','🛡️','🧠','📡','🛰️','🗝️','💫','🌈'
    ];
    const e1 = emojis[arr[0] % emojis.length];
    const e2 = emojis[arr[1] % emojis.length];
    const h1 = arr[2].toString(16).padStart(2,'0');
    const h2 = arr[3].toString(16).padStart(2,'0');
    const h3 = arr[4].toString(16).padStart(2,'0');
    return `${e1}${e2}-${h1}${h2}${h3}`.toUpperCase();
  }

  // Extract DTLS certificate fingerprint from SDP (first occurrence)
  function sdpFingerprint(sdp) {
    const m = sdp.match(/a=fingerprint:\s*[\w-]+\s+([0-9A-Fa-f:]+)/);
    if (!m) return '';
    return m[1].replace(/:/g,'').toLowerCase();
  }

  // ---- Crypto session ------------------------------------------------------

  class CryptoSession {
    constructor() {
      this.ecdhKeyPair = null;
      this.peerPubRaw = null;
      this.sharedKey = null;       // CryptoKey AES-GCM
      this.keyReady = false;
      this.sas = '—';
      this.senderPrefix = null;    // 6 bytes unique per side
      this.sendCounter = 0n;       // 48-bit
    }

    async generateEphemeral() {
      this.ecdhKeyPair = await crypto.subtle.generateKey(
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveBits']
      );
    }

    async exportPublicRaw() {
      return await crypto.subtle.exportKey('raw', this.ecdhKeyPair.publicKey);
    }

    async importPeerPublicRaw(rawArrayBuffer) {
      this.peerPubRaw = rawArrayBuffer;
      this.peerPublicKey = await crypto.subtle.importKey(
        'raw', rawArrayBuffer,
        { name: 'ECDH', namedCurve: 'P-256' },
        false, []
      );
    }

    async derive(sharedBindInfo) {
      // ECDH derive -> HKDF for key, sas, and local sender prefix
      const ecdhBits = await crypto.subtle.deriveBits(
        { name: 'ECDH', public: this.peerPublicKey },
        this.ecdhKeyPair.privateKey,
        256
      );
      // Bind to DTLS fingerprints to detect SDP tampering
      const bindInfo = `scs-chat-bind-v1:${sharedBindInfo}`;
      const keyBytes = await hkdf(ecdhBits, `scs-chat-key-v1|${bindInfo}`, 32);
      const sasBytes = await hkdf(ecdhBits, `scs-chat-sas-v1|${bindInfo}`, 5);
      const senderIdHash = await sha256(await this.exportPublicRaw());
      const prefix = new Uint8Array(senderIdHash).slice(0, 6); // 6 bytes
      this.senderPrefix = prefix;

      this.sharedKey = await crypto.subtle.importKey(
        'raw', keyBytes,
        { name: 'AES-GCM', length: 256 },
        false, ['encrypt','decrypt']
      );
      this.sas = formatSAS(sasBytes);
      this.keyReady = true;
    }

    buildNonce() {
      // 12 bytes: 6-byte prefix + 6-byte counter (big-endian)
      const nonce = new Uint8Array(12);
      nonce.set(this.senderPrefix, 0);
      const c = this.sendCounter;
      for (let i=0; i<6; i++) {
        // write from end
        nonce[11 - i] = Number((c >> BigInt(i*8)) & 0xffn);
      }
      this.sendCounter = (this.sendCounter + 1n) & ((1n<<48n)-1n);
      return nonce;
    }

    async encrypt(plaintext) {
      if (!this.keyReady) throw new Error('key not ready');
      const iv = this.buildNonce();
      const ct = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv, additionalData: undefined, tagLength: 128 },
        this.sharedKey,
        enc.encode(plaintext)
      );
      return { n: b64u(iv.buffer), c: b64u(ct) };
    }

    async decrypt(nonceB64u, ctB64u) {
      if (!this.keyReady) throw new Error('key not ready');
      const iv = new Uint8Array(b64uToBuf(nonceB64u));
      const ct = b64uToBuf(ctB64u);
      const pt = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv, additionalData: undefined, tagLength: 128 },
        this.sharedKey,
        ct
      );
      return dec.decode(pt);
    }
  }

  // ---- WebRTC core ---------------------------------------------------------

  class P2P {
    constructor({ useStun, onStatus, onPill, onMessage, onOpen, onClose, onLog }) {
      this.useStun = !!useStun;
      this.onStatus = onStatus;
      this.onPill = onPill;
      this.onMessage = onMessage;
      this.onOpen = onOpen;
      this.onClose = onClose;
      this.onLog = onLog || (()=>{});

      this.pc = null;
      this.dc = null;
      this.role = 'none'; // offerer|answerer|none
      this.crypto = new CryptoSession();

      this.localFP = '';
      this.remoteFP = '';
    }

    _iceServers() {
      return this.useStun ? [{ urls: ['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478'] }] : [];
    }

    async setupPC() {
      this.pc = new RTCPeerConnection({ iceServers: this._iceServers() });
      this.pc.onicegatheringstatechange = () => {
        this.onPill('ice', `ICE: ${this.pc.iceGatheringState}`);
      };
      this.pc.oniceconnectionstatechange = () => {
        this.onStatus(`ICE state: ${this.pc.iceConnectionState}`);
      };
      this.pc.onsignalingstatechange = () => {
        this.onStatus(`Signaling: ${this.pc.signalingState}`);
      };
      this.pc.onconnectionstatechange = () => {
        this.onStatus(`Peer: ${this.pc.connectionState}`);
        if (this.pc.connectionState === 'failed' || this.pc.connectionState === 'disconnected') {
          this.onClose();
        }
      };
      this.pc.ondatachannel = (e) => {
        this.bindDC(e.channel);
      };
    }

    bindDC(dc) {
      this.dc = dc;
      this.dc.onopen = () => {
        this.onPill('dc', 'Data channel: open');
        this.onOpen();
      };
      this.dc.onclose = () => {
        this.onPill('dc', 'Data channel: closed');
        this.onClose();
      };
      this.dc.onmessage = async (e) => {
        try {
          const msg = JSON.parse(e.data);
          if (msg.t === 'm') {
            const text = await this.crypto.decrypt(msg.n, msg.c);
            this.onMessage('peer', text);
          }
        } catch (err) {
          this.onLog('Recv error', err);
        }
      };
    }

    async awaitIceComplete() {
      if (this.pc.iceGatheringState === 'complete') return;
      await new Promise((resolve) => {
        const check = () => {
          if (this.pc.iceGatheringState === 'complete') {
            this.pc.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        };
        this.pc.addEventListener('icegatheringstatechange', check);
      });
    }

    async createOfferPackage() {
      this.role = 'offerer';
      this.onPill('role', 'Role: offerer');
      await this.setupPC();
      await this.crypto.generateEphemeral();

      // Create DC proactively
      const dc = this.pc.createDataChannel('scs', { ordered: true, negotiated: false });
      this.bindDC(dc);

      const offer = await this.pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
      await this.pc.setLocalDescription(offer);

      // Local fingerprint for bind
      this.localFP = sdpFingerprint(this.pc.localDescription.sdp);

      await this.awaitIceComplete();

      const pubRaw = await this.crypto.exportPublicRaw();
      const pkg = {
        v: 1,
        type: 'offer',
        kty: 'p256-raw',
        key: b64u(pubRaw),
        sdp: this.pc.localDescription.sdp,
        stun: this.useStun ? 1 : 0
      };
      return pack(pkg);
    }

    async acceptOfferAndCreateAnswerPackage(offerPkgStr) {
      this.role = 'answerer';
      this.onPill('role', 'Role: answerer');
      await this.setupPC();
      await this.crypto.generateEphemeral();

      const pkg = unpack(offerPkgStr);
      if (pkg.type !== 'offer') throw new Error('Not an offer package');
      if (pkg.kty !== 'p256-raw') throw new Error('Unsupported key type');

      this.useStun = !!pkg.stun; // mirror peer preference
      // Recreate PC with mirrored ICE servers if needed (simplify: keep current)

      await this.crypto.importPeerPublicRaw(b64uToBuf(pkg.key));

      // Set remote description
      await this.pc.setRemoteDescription({ type: 'offer', sdp: pkg.sdp });
      this.remoteFP = sdpFingerprint(pkg.sdp);

      // Create answer
      const answer = await this.pc.createAnswer();
      await this.pc.setLocalDescription(answer);

      this.localFP = sdpFingerprint(this.pc.localDescription.sdp);

      await this.awaitIceComplete();

      // Derive keys bound to both FPs (role-sensitive binding string to align)
      const bindInfo = `offererFP=${this.remoteFP}|answererFP=${this.localFP}`;
      await this.crypto.derive(bindInfo);

      const myPub = await this.crypto.exportPublicRaw();
      const ansPkg = {
        v: 1,
        type: 'answer',
        kty: 'p256-raw',
        key: b64u(myPub),
        sdp: this.pc.localDescription.sdp
      };

      return { pkg: pack(ansPkg), sas: this.crypto.sas };
    }

    async applyAnswerPackage(answerPkgStr) {
      const pkg = unpack(answerPkgStr);
      if (pkg.type !== 'answer') throw new Error('Not an answer package');
      await this.crypto.importPeerPublicRaw(b64uToBuf(pkg.key));

      await this.pc.setRemoteDescription({ type: 'answer', sdp: pkg.sdp });
      this.remoteFP = sdpFingerprint(pkg.sdp);

      // Bind with both FPs
      const bindInfo = `offererFP=${this.localFP}|answererFP=${this.remoteFP}`;
      await this.crypto.derive(bindInfo);

      this.onPill('sec', `Key: ready`);
      return this.crypto.sas;
    }

    async send(text) {
      if (!this.dc || this.dc.readyState !== 'open') throw new Error('Channel not open');
      const { n, c } = await this.crypto.encrypt(text);
      const frame = JSON.stringify({ t: 'm', n, c });
      this.dc.send(frame);
    }

    close() {
      try { this.dc && this.dc.close(); } catch {}
      try { this.pc && this.pc.close(); } catch {}
    }
  }

  // ---- UI wiring -----------------------------------------------------------

  const $ = (id) => document.getElementById(id);

  const ui = {
    useStun: $('useStun'),
    netStatus: $('netStatus'),
    rolePill: $('rolePill'),
    dcPill: $('dcPill'),
    icePill: $('icePill'),
    secPill: $('secPill'),
    sasPill: $('sasPill'),
    sasText: $('sasText'),

    btnCreateOffer: $('btnCreateOffer'),
    btnApplyAnswer: $('btnApplyAnswer'),
    btnAcceptOffer: $('btnAcceptOffer'),

    offerOut: $('offerOut'),
    answerIn: $('answerIn'),
    offerIn: $('offerIn'),
    answerOut: $('answerOut'),

    copyOffer: $('copyOffer'),
    copyAnswer: $('copyAnswer'),

    btnReset1: $('btnReset1'),
    btnReset2: $('btnReset2'),

    chatLog: $('chatLog'),
    msgInput: $('msgInput'),
    btnSend: $('btnSend'),
  };

  let p2p = null;

  function resetUI() {
    ui.netStatus.textContent = 'Idle';
    ui.rolePill.textContent = 'Role: none';
    ui.dcPill.textContent = 'Data channel: closed';
    ui.icePill.textContent = 'ICE: new';
    ui.secPill.textContent = 'Key: not ready';
    ui.sasPill.textContent = 'SAS: —';
    ui.sasText.textContent = '—';

    ui.offerOut.value = '';
    ui.answerIn.value = '';
    ui.offerIn.value = '';
    ui.answerOut.value = '';

    ui.btnApplyAnswer.disabled = true;
    ui.btnSend.disabled = true;
    ui.msgInput.value = '';
    ui.msgInput.placeholder = 'Type a secure message...';
  }

  function logMsg(kind, text) {
    const div = document.createElement('div');
    div.className = 'msg ' + (kind === 'me' ? 'me' : 'peer');
    const ts = new Date().toLocaleTimeString();
    div.textContent = `[${ts}] ${kind === 'me' ? 'You' : 'Peer'}: ${text}`;
    ui.chatLog.appendChild(div);
    ui.chatLog.scrollTop = ui.chatLog.scrollHeight;
  }

  function setStatus(t) {
    ui.netStatus.textContent = t;
  }
  function setPill(which, text) {
    const map = { role: ui.rolePill, dc: ui.dcPill, ice: ui.icePill, sec: ui.secPill, sas: ui.sasPill };
    (map[which] || ui.netStatus).textContent = text;
  }

  function newP2P() {
    if (p2p) { try { p2p.close(); } catch {} }
    p2p = new P2P({
      useStun: ui.useStun.checked,
      onStatus: setStatus,
      onPill: setPill,
      onMessage: (who, text) => logMsg(who, text),
      onOpen: () => {
        ui.btnSend.disabled = false;
        setStatus('Connected');
      },
      onClose: () => {
        ui.btnSend.disabled = true;
        setStatus('Disconnected');
      },
      onLog: console.debug
    });
  }

  // Initial state
  resetUI();
  newP2P();

  // Handlers
  ui.btnCreateOffer.addEventListener('click', async () => {
    try {
      resetUI();
      newP2P();
      setStatus('Creating offer…');
      const pkg = await p2p.createOfferPackage();
      ui.offerOut.value = pkg;
      ui.btnApplyAnswer.disabled = false;
      ui.sasText.textContent = '—';
      ui.sasPill.textContent = 'SAS: —';
      setPill('sec', 'Key: waiting for answer');
      setStatus('Offer ready. Send to peer.');
    } catch (e) {
      setStatus('Failed to create offer');
      console.error(e);
    }
  });

  ui.btnApplyAnswer.addEventListener('click', async () => {
    try {
      setStatus('Applying answer…');
      const sas = await p2p.applyAnswerPackage(ui.answerIn.value.trim());
      ui.sasText.textContent = sas;
      ui.sasPill.textContent = `SAS: ${sas}`;
      setPill('sec', 'Key: ready');
      setStatus('Answer applied. Waiting for channel…');
    } catch (e) {
      setStatus('Failed to apply answer');
      console.error(e);
    }
  });

  ui.btnAcceptOffer.addEventListener('click', async () => {
    try {
      resetUI();
      newP2P();
      setStatus('Accepting offer…');
      const { pkg, sas } = await p2p.acceptOfferAndCreateAnswerPackage(ui.offerIn.value.trim());
      ui.answerOut.value = pkg;
      ui.sasText.textContent = sas;
      ui.sasPill.textContent = `SAS: ${sas}`;
      setPill('sec', 'Key: ready');
      setStatus('Answer ready. Send back to peer.');
    } catch (e) {
      setStatus('Failed to accept offer');
      console.error(e);
    }
  });

  ui.copyOffer.addEventListener('click', async () => {
    if (!ui.offerOut.value) return;
    await navigator.clipboard.writeText(ui.offerOut.value);
    setStatus('Offer copied');
  });
  ui.copyAnswer.addEventListener('click', async () => {
    if (!ui.answerOut.value) return;
    await navigator.clipboard.writeText(ui.answerOut.value);
    setStatus('Answer copied');
  });

  ui.btnSend.addEventListener('click', async () => {
    const txt = ui.msgInput.value.trim();
    if (!txt) return;
    try {
      await p2p.send(txt);
      logMsg('me', txt);
      ui.msgInput.value = '';
      ui.msgInput.focus();
    } catch (e) {
      setStatus('Send failed');
      console.error(e);
    }
  });

  ui.msgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      ui.btnSend.click();
    }
  });

  ui.btnReset1.addEventListener('click', () => {
    resetUI();
    newP2P();
  });
  ui.btnReset2.addEventListener('click', () => {
    resetUI();
    newP2P();
  });

  ui.useStun.addEventListener('change', () => {
    setStatus(ui.useStun.checked ? 'Public STUN enabled' : 'Public STUN disabled');
  });

})();
